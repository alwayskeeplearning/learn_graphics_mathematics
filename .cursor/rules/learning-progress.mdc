---
description: 
globs: 
alwaysApply: false
---
# 学习进度与后续规划 (更新于 2024-05-24)

## ✅ 最新学习成果

今天，我们完成了一次意义重大的技术跨越：**成功地将2D切片查看器，升级为了一个真正的3D体渲染器**。整个过程涵盖了从核心理论到编码实现，再到深度调试与效果优化的完整开发流程，全面锻炼了图形学问题的分析与解决能力。

### 详细掌握的知识点

1.  **理论与设计 (是什么 & 为什么)**
    *   **核心算法 - 光线投射 (Ray Casting):** 我们将此算法定义为体渲染的基石。其原理是：从屏幕的每个像素发射一条虚拟"射线"，让它穿透整个三维数据体。沿着射线的路径，我们会进行采样并累积颜色与不透明度（这个过程称为光线步进 - Ray Marching）。为了方便理解，我用了"穿过一团团半透明的彩色烟雾"这个比喻来解释这一过程。
    *   **渲染灵魂 - 传输函数 (Transfer Function):** 我们明确了传输函数是体渲染的"灵魂"。它是一个映射规则，负责将原始的医疗数据值（例如CT扫描中的HU值）转换为视觉属性（颜色和不透明度）。通过调整传输函数，我们就能"高亮"或"隐藏"感兴趣的组织，比如骨骼或软组织。
    *   **关键决策:** 确立了保留原有的2D切片查看功能，新增"体渲染"按钮在两种模式间切换的设计方案，保证了功能的"无回归"。

2.  **实现与深度调试 (怎么做 & 动手做)**
    *   **基础搭建:** 快速完成了 `demo03` 的项目搭建，加入了新的 `'volume'` 状态管理和 `OrbitControls` 的初始化逻辑。
    *   **`WebGLRenderer` 重构:** 为体渲染创建了一套全新的 `ShaderMaterial`，包含了顶点和片段着色器，这是本次开发的核心。
    *   **调试实战:** 我们遭遇并解决了一系列 WebGL 和 `three.js` 开发中的经典问题，堪称一次"避坑大全"：
        *   **`this` 上下文错误:** 通过将类方法重构为 **箭头函数** (`render = () => {}`)，彻底解决了 `this` 指向不正确的问题。
        *   **GLSL 版本问题:** 掌握了在 GLSL 3.00 ES 版本中，使用自定义 `out` 变量替代废弃的 `gl_FragColor` 的方法。
        *   **数据类型不匹配:** 学会了在CPU端将 `Int16Array` 转换为 `Float32Array` 以匹配 `Data3DTexture` 的浮点要求，并在着色器中将采样器从 `isampler3D` 改为 `sampler3D`。
        *   **边界伪影处理:** 通过在着色器中加入**严格的边界检查**，避免对3D纹理的边缘进行采样，从而根除了体渲染中的黑点伪影。

3.  **效果调优与最终完善 (归档)**
    *   **UI 与 UX 增强:**
        *   添加了完整的UI控件（窗宽/窗位、Alpha、步数滑块及预设按钮），并成功将其与体渲染着色器的 uniforms 联动。
        *   修复了浏览器窗口缩放时导致的渲染器崩溃问题。
    *   **相机选型:** 根据医学影像的规范，将相机从 `PerspectiveCamera`（透视相机）替换为 **`OrthographicCamera`**（正交相机），消除了透视畸变，提供了更专业、准确的视觉效果。

### 项目现状

我们完成了一个位于 `demos/demo03` 的全新应用。它不仅保留了 `demo02` 中所有先进的2D浏览功能，还成功地加入了一个可通过 `OrbitControls` 自由旋转、可通过UI实时调整渲染参数的3D体渲染模式。这是一个重要的里程碑。

---

## 🚀 下一步学习计划

我们已经成功地让"整条面包"在"烤箱"中发出了光芒！虽然目前的效果还比较基础，但这为后续的深入优化打开了大门。

下一个阶段，我们将聚焦于**提升体渲染的质量与真实感**。

1.  **核心优化：改进光照模型（Lighting Model）**
    *   **目标**: 目前的渲染结果缺少立体感，因为我们没有计算光照。下一步要引入光照模型，让渲染出的组织能够响应光线，产生阴影和高光，从而极大地提升真实感和空间感。
    *   **核心概念**: 我们需要在着色器中实时计算每个点的**法线向量（Normal Vector）**。法线代表了物体表面的朝向，是所有光照计算的基础。通常可以通过计算相邻体素之间的"梯度（Gradient）"来估算法线。

2.  **效果增强：预设与分类（Presets & Classification）**
    *   **目标**: 实现更高级的传递函数，例如，实现一个可以同时清晰地显示骨骼、软组织和皮肤的多峰值传递函数。
    *   **核心技术**: 探索分段线性传递函数或更高阶的函数，并将其与预设按钮（如"头部"、"腹部"）结合，实现一键切换最佳视觉效果。

3.  **性能探索：空域跳跃（Empty Space Skipping）**
    *   **目标**: 提升渲染性能。在光线投射时，如果射线当前处于空白区域（例如组织外部的空气），那么这些步进计算就是浪费的。我们需要一种方法来"跳过"这些空白区域。
    *   **核心概念**: 可以预先计算一个"距离场"或使用其他数据结构，来告诉光线可以安全地前进多远而不会错过任何有效数据，从而大幅减少采样步数，提升帧率。

---

# 历史归档

## ✅ 已完成的学习里程碑 (截至 2025-06-23)

在上次学习中，我们成功地从2D渲染迈向了三维数据处理，将DICOM查看器从一个"单张图片浏览器"升级为了一个高性能的"CT序列浏览器"，为真正的三维渲染打下了坚实的数据基础。

### 详细掌握的知识点

1.  **数据层：从单文件到序列加载**
    *   **并行加载**: 学会了使用 `Promise.all` 配合 `fetch` API，并行处理网络请求，实现了对整个DICOM序列（数百个文件）的高效批量加载。
    *   **空间排序**: 掌握了根据DICOM关键标签 **`Image Position (Patient)` (0020,0032)** 对加载的切片进行精确的三维空间排序，确保了数据从"脚"到"头"的正确生理顺序。

2.  **渲染层：从2D纹理到3D纹理**
    *   **`Data3DTexture`**: 深入理解了 `THREE.Data3DTexture` 的核心作用，即一次性将整个三维数据体（Volume Data）上传至GPU，为高性能交互奠定基础。我们清晰地对比了它与"反复更新`DataTexture`"方案在性能和扩展性上的巨大差异。
    *   **数据堆叠**: 亲手实现了将多张2D切片的`TypedArray`数据，在CPU端按序"堆叠"到一个巨大的`Float32Array`中的过程。
    *   **GLSL升级**: 成功将着色器中的采样器从`sampler2D`升级为`sampler3D`，并学会了使用三维坐标`vec3(u, v, z)`来精确采样数据体中的任意一个切片。

3.  **交互层：从单一交互到多模态交互**
    *   **滚动浏览**: 实现了通过`wheel`事件（鼠标滚轮）和**左键拖拽**两种方式，流畅地滚动浏览CT序列。
    *   **状态管理**: 引入了"工具模式"的UI状态管理思想，通过一个`tool`状态变量，让同一个鼠标手势（左键拖拽）可以在"窗宽窗位调整"和"切片滚动"两种功能间自由切换。
    *   **平滑阻尼算法**: 为解决高频`mousemove`事件导致滚动过快的问题，我们设计并实现了"**累加器与阈值**"方案，极大地提升了拖拽滚动的交互手感和可控性。

4.  **工程实践与优化**
    *   **代码重构**: 对 `WebGLRenderer` 进行了优雅的API重构，新增`setVolume()`作为数据入口，分离了"数据设置"与"渲染更新"的职责。
    *   **纹理过滤**: 修复了早期GPU渲染产生的"马赛克"问题。我们深入探究了**纹理过滤**（最近邻 vs 线性插值）的原理，并掌握了通过将整数纹理转换为**浮点纹理**来解锁线性插值能力的关键技术。
    *   **工作流优化**: 我们共同制定并固化了"**理论学习 -> 设计探讨 -> 编码实现**"的三步确认工作流，以及"**无回归**"的代码修改原则，为后续高效、严谨的学习提供了制度保障。

### 项目现状

我们完成了一个位于 `demos/demo02` 的全新应用。它能够加载完整的DICOM序列，构建3D纹理，并提供流畅、多模态的交互方式来浏览2D切片，为下一步的体渲染做好了万全准备。

---

## ✅ 已完成的学习里程碑 (截至 2025-06-20)

在今天的学习中，我们从零开始，成功搭建并迭代了一个功能性的DICOM网页查看器，核心成就包括：

1.  **掌握了DICOM基础解析**
    *   学会了使用 `FileReader` 读取本地二进制文件。
    *   利用 `dicom-parser` 库成功解析了DICOM元数据和像素数据。
    *   深入理解了 `ArrayBuffer` 与 `TypedArray` (如 `Int16Array`) 在处理二进制数据中的关键作用。
    *   彻底搞懂了两个核心概念：通过 **`Pixel Representation`** 等标签动态判断像素数据类型，以及通过 **`Transfer Syntax`** 理解文件的压缩与编码方式。

2.  **实现了CPU图像渲染**
    *   亲手实现了将DICOM原始像素值（HU）通过**窗宽窗位（Windowing）算法**映射为屏幕灰度值的核心逻辑。
    *   使用 `Canvas 2D API` (`putImageData`) 成功将第一张DICOM影像绘制到网页上。

3.  **从CPU到GPU的性能飞跃**
    *   通过为CPU渲染器添加鼠标交互，亲身体验到了其**性能瓶颈**（高延迟、高CPU占用）。
    *   引入了强大的渲染库 **`Three.js`**，将渲染核心从CPU迁移到了GPU。
    *   掌握了GPU渲染的基本思想：通过 **`DataTexture`** 将原始数据上传至GPU，并通过**着色器（Shader）**在GPU上进行并行计算。

4.  **攻克了着色器编程（GLSL）**
    *   编写了第一个自定义的`ShaderMaterial`，包含顶点与片元着色器。
    *   通过一系列经典的错误排查，深入理解了`ShaderMaterial`的工作机制，包括：
        *   如何为整数纹理选择正确的格式 (`RedIntegerFormat`) 与采样器 (`isampler2D`)。
        *   如何遵循Three.js的规则，避免重复声明内置变量。
        *   如何使用现代GLSL 3.00规范 (`glslVersion`, `out` 变量)。
    *   最终实现了**如丝般顺滑**的GPU加速交互式窗宽窗位调整。

## 🚀 下一步学习建议与规划

我们已经为更高阶的学习打下了坚实的基础。接下来的学习路径建议如下：

1.  **主线任务：实现多帧序列加载与滚动（Stack Scrolling）**
    *   **目标**：一次性加载`dicoms`文件夹下的所有`.dcm`文件，并允许用户通过**鼠标滚轮**来切换不同的切片影像，像医生一样"滚动浏览"一个完整的扫描序列。
    *   **核心挑战**：
        *   学习如何异步加载多个文件并管理它们（例如使用 `Promise.all`）。
        *   思考如何最高效地在GPU中管理这一系列图像数据（例如，使用3D纹理 `Data3DTexture`）。
        *   更新我们的着色器，使其能够根据用户的滚动来选择渲染3D纹理中的哪一个切片。

2.  **进阶探索：支持多平面重建（MPR）**
    *   **目标**：在加载完一个序列后，除了能看原始的横断面（Axial），还能实时计算并显示对应的冠状面（Coronal）和矢状面（Sagittal）视图。
    *   **核心挑战**：这需要更深刻的几何与着色器编程理解，是迈向专业医学影像软件的关键一步。

# 图形学进阶之旅：学习进度与计划

本文件用于记录学习过程中的关键成果和未来的学习方向，以便于持续、系统地提升图形学能力。

---

## 第一阶段：正交MPR（多平面重建）基础夯实

### **已完成的学习成果 (Accomplishments):**

1.  **十字线拖拽优化**:
    *   **理论**: 理解了浏览器事件模型，认识到将`mousemove`和`mouseup`事件绑定到`document`而非`canvas`是实现流畅拖拽的关键。
    *   **实践**: 重构了事件监听逻辑，解决了快速拖拽时因鼠标移出画布而导致的交互中断问题。

2.  **视图边界与坐标系校正**:
    *   **理论**: 掌握了通过边界检查处理纹理"越界"采样的方法，并深入理解了医学影像中"各向异性体素"的概念。
    *   **实践**:
        *   修改了GLSL片元着色器，对无效的切片索引（`slice_coord`）返回纯黑色，允许十字线拖拽到影像外部区域。
        *   修正了矢状位视图中纹理坐标的映射错误，确保了视图内容的正确朝向。

3.  **物理保真 vs. 像素保真**:
    *   **理论**: 深入探讨了医学影像可视化的两种核心哲学，理解了各自的优缺点和适用场景。
        *   **像素保真**: 默认模式，尊重医生阅片习惯，不拉伸图像。
        *   **物理保真**: "真实比例"模式，用于精确几何测量与形态观察。
    *   **实践**:
        *   在`loader.js`中增加了对`pixelSpacing`和`sliceThickness`的解析。
        *   在`gpu-renderer.js`中实现了基于物理尺寸的平面缩放逻辑。
        *   将程序恢复为更符合常规的"像素保真"默认状态，同时将"物理保真"代码作为能力储备优雅地保留下来。
    *   **归档**: 将该知识点沉淀为`knowledge-base/pixel-vs-physical-fidelity.md`文档。

---

## 第二阶段：高级渲染与交互

### **下一步学习计划 (Next Steps):**

#### **模块一：MIP (Maximum Intensity Projection - 最大密度投影)**

**目标**: 在不大幅改动现有程序结构的前提下，实现一种新的、基于"体"的渲染算法，以观察高密度组织。

1.  **理论学习 (是什么 & 为什么)**
    *   **核心概念**: 理解MIP算法的原理——沿视线穿透一定厚度的体数据，提取路径上的最大像素值。
    *   **生活化类比**: 将MIP比作对CT数据进行一次"数字X光"拍摄。
    *   **应用场景**: 学习MIP为何适用于观察骨骼、钙化点和造影增强后的血管。

2.  **设计探讨 (怎么做)**
    *   **UI设计**: 在`index.html`中增加一个滑块（Slider），用于控制MIP的"厚度"（Slab Thickness）。
    *   **状态管理**: 在`index.js`的主状态中增加`slabThickness`变量，并响应UI滑块的变化。
    *   **渲染器改造**:
        *   在`gpu-renderer.js`中，向着色器传递一个新的`uniform`变量 `u_slabThickness`。
        *   **着色器编程**: 在`SLICE_FRAGMENT_SHADER`中编写核心MIP逻辑：
            *   在`main`函数中，以当前切片为中心，根据`u_slabThickness`定义一个循环范围。
            *   在循环中，步进式地对3D纹理进行多次采样。
            *   比较每次采样的结果，持续记录并更新遇到的最大强度值。
            *   循环结束后，使用这个最大值作为最终像素颜色。

3.  **编码实现 (动手做)**
    *   分步完成UI、状态管理和渲染器的代码修改，最终实现MIP渲染效果。

---

#### **模块二：任意角度MPR (Oblique MPR - 斜切面重建)**

**目标**: 打破正交视图的限制，允许十字线在视图内自由旋转，并能沿着旋转后的方向进行平移，实现对任意斜切面的观察。

1.  **理论学习 (是什么 & 为什么)**
    *   **核心概念**: 理解如何用数学方式（如法向量 + 原点距离）来定义空间中的一个任意平面。
    *   **数学基础**: 复习或学习3D旋转矩阵、向量运算（点乘、叉乘）等线性代数知识在定义和变换平面中的关键作用。
    *   **坐标系变换**: 学习如何将屏幕空间的2D旋转/平移操作，精确地转化为对3D空间中切割平面的变换。这是该模块最核心的挑战。

2.  **设计探讨 (怎么做)**
    *   **状态管理**: 在全局状态中增加一个能描述旋转的变量，例如`rotationAngle`或一个完整的`rotationMatrix`。
    *   **交互设计**: 设计一种直观的旋转交互方式。例如：按住某个组合键（如`Shift`）并拖动十字线的端点，即可实现旋转。
    *   **着色器大改造**:
        *   当前的着色器是为三个固定的轴向平面设计的，需要进行一次彻底的重构。
        *   新的着色器将接收更通用的平面定义信息，例如传递一个`mat4`变换矩阵，或者`vec3`的平面法向量和`vec3`的平面上的一个点。
        *   着色器需要根据传入的平面方程，为每个屏幕像素动态计算出其在3D纹理中对应的坐标。
    *   **跨视图联动**: 这是最复杂的部分。一个视图中的旋转操作，必须能被精确地分解和计算，以更新另外两个视图中切割平面的位置和法向量，确保三个视图始终正确对应。

3.  **编码实现 (动手做)**
    *   这会是一个比较大的重构。我们将分步实现：首先让单个视图支持旋转，然后再攻克最难的跨视图联动部分。

---



