# 影像保真度之争：像素保真 vs 物理保真

在医学影像可视化，尤其是多平面重建（MPR）中，一个核心的设计决策是：我们应该如何展示不同切面的图像？这引出了两种基本的可视化哲学："像素保真"和"物理保真"。

## 1. 核心概念：体素的各向异性（Anisotropic Voxel）

问题的根源在于，CT扫描产生的体素（Voxel，即3D像素）在物理世界中通常不是一个完美的正方体。

- **像素间距 (Pixel Spacing)**：定义了在单个2D图像上，像素在X和Y方向的物理尺寸（如 `0.7mm x 0.7mm`）。
- **层厚 (Slice Thickness)**：定义了在Z方向上，相邻两张2D图像之间的物理距离（如 `5mm`）。

因此，一个体素的真实物理尺寸可能是 `0.7mm x 0.7mm x 5mm`，它是一个扁长的"芯片"，而非正方体。这种各维度物理尺寸不一致的特性，就是"各向异性"。

---

## 2. 两种显示哲学

### 像素保真 (Pixel Fidelity)

也称为**各向同性显示 (Isotropic Display)**。

- **是什么**：此模式**忽略**体素的物理尺寸差异，将每个体素都当作一个完美的正方体来渲染。例如，一个 `512x512` 的轴位切片和一个 `512x150` 的冠状位切片，都会被直接当作二维像素矩阵来显示，不进行任何拉伸。
- **优点**:
  - **阅片习惯**：符合放射科医生长期形成的临床阅片习惯。
  - **图像清晰**：避免因拉伸和插值计算引入的图像模糊。
  - **数据原始**：展示的是最直接、未经几何变换的原始数据。
- **缺点**:
  - **形态失真**：无法准确反映病灶或组织的真实三维形态。一个球形的肿瘤在冠状位或矢状位上可能会被严重压扁成一个椭球形。
- **应用场景**：常规的临床阅片、诊断。
- **类比**：**墨卡托投影法**的世界地图。它为了保证导航时的角度正确，牺牲了面积的真实比例（如格陵兰岛看起来和非洲一样大）。

### 物理保真 (Physical Fidelity)

也称为**各向异性显示 (Anisotropic Display)**。

- **是什么**：此模式读取 `PixelSpacing` 和 `SliceThickness` 等DICOM元数据，计算出体素在X, Y, Z三个轴上的真实物理尺寸比例，然后**拉伸**渲染平面，使得屏幕上显示的图像长宽比与真实世界的物理尺寸长宽比完全一致。
- **优点**:
  - **几何准确**：能精确地反映解剖结构的真实形态和比例。
- **缺点**:
  - **可能模糊**：拉伸过程需要进行纹理插值，可能会引入一定的模糊。
  - **改变习惯**：与传统的阅片方式不同。
- **应用场景**：精确的几何测量、手术入路规划、3D打印、科研分析等。
- **类比**：**等积投影法**的世界地图。它保证了各个国家真实的面积比例，但可能会扭曲其原始的形状。

---

## 3. 实现策略：如何优雅地切换

一个优秀的医学影像浏览器应该**同时具备**这两种能力，并将决定权交给用户。

1.  **默认像素保真**：将"不拉伸"作为默认显示模式，符合大多数用户的阅片习惯。在`Three.js`中，这意味着渲染平面的 `scale` 保持为 `(1, 1, 1)`。
2.  **提供切换开关**：在UI上提供一个例如"显示真实比例"的按钮。
3.  **激活物理保真**：当用户激活此开关时，程序读取`metaData`中的物理尺寸信息，计算出正确的长宽比，并将其应用到渲染平面的`scale`属性上。

#### 示例代码（Three.js）

```javascript
// 默认像素保真
this.slicePlane.scale.set(1, 1, 1);

// --- 激活物理保真 ---
// 1. 读取元数据
const { width, height, depth, pixelSpacing, sliceThickness } = metaData;

// 2. 计算物理尺寸
const physicalWidth = width * pixelSpacing[0];
const physicalHeight = height * pixelSpacing[1];
const physicalDepth = depth * sliceThickness;

// 3. 根据视图方向，计算长宽比
let aspectRatioX, aspectRatioY;
if (orientation === 'coronal') {
  // XZ平面
  aspectRatioX = physicalWidth;
  aspectRatioY = physicalDepth;
} // ... 其他方向

// 4. 归一化并应用缩放
const maxDim = Math.max(aspectRatioX, aspectRatioY);
this.slicePlane.scale.set(aspectRatioX / maxDim, aspectRatioY / maxDim, 1);
```

通过这种方式，我们既尊重了用户的传统习惯，又提供了进行精确几何分析的强大能力。
