# 知识点总结：精通Three.js中的DataTexture

在Three.js中，当我们需要处理的不是标准的图片文件（如.jpg, .png），而是来自科学计算、程序生成的原始数据（如DICOM像素数据）时，`THREE.DataTexture` 就成了我们的核心工具。本文档旨在深入解析`DataTexture`的构造、更新机制以及一个最关键的概念——数据归一化。

## 1. `DataTexture` 构造函数：一份详尽的"报关单"

`DataTexture`的构造函数需要我们提供详尽的参数，像一份"报关单"一样，精确地告诉GPU我们所提供的数据的完整信息。

`const texture = new THREE.DataTexture(data, width, height, format, type);`

- **`data`**: "原材料"，必须是一个类型化数组（`TypedArray`），如`Int16Array`, `Float32Array`等。
- **`width`**: 纹理的水平像素数量。
- **`height`**: 纹理的垂直像素数量。
- **`format`**: "数据格式"，告诉GPU如何解释`data`中的每个数字，即它代表哪些颜色通道。
- **`type`**: "数据类型"，告诉GPU `data`数组中每个数字本身的基础类型（8位/16位/32位，有/无符号，整型/浮点型）。

**示例**：
为一段`Int16Array`类型的DICOM像素数据创建纹理时，我们会这样写：

```javascript
const texture = new THREE.DataTexture(
  pixelData, // Int16Array
  columns, // 图像宽度
  rows, // 图像高度
  THREE.RedIntegerFormat, // 格式：单通道整数
  THREE.ShortType, // 类型：16位有符号短整型
);
```

---

## 2. `texture.needsUpdate`: 从"办公室"到"工厂"的通知单

理解`needsUpdate`的关键，是理解CPU和GPU的分工。

- **类比**：
  - **CPU (办公室)**: JavaScript代码运行的地方，我们在这里准备数据。
  - **GPU (工厂)**: 进行海量并行计算（渲染）的地方，它有自己的仓库（VRAM/显存）。
  - **数据上传**: 将数据从CPU内存拷贝到GPU显存是一个高成本操作。
- **`texture.needsUpdate = true` 的作用**：
  它就像一张一次性的"特别通知单"，你通过它告诉Three.js："我办公室里的数据有更新，请在下次渲染前，必须把它重新运送到工厂仓库里去！"

### 使用时机

1.  **初次创建纹理后**：`new DataTexture()` 只是在JS环境中创建了对象，设置`needsUpdate = true`才会触发第一次真正的数据上传。
2.  **当纹理的源数据在JS中被修改后**：如果你在代码中改变了`data`数组的内容，必须再次设置`needsUpdate = true`来强制GPU同步这些改动。

**严禁**在渲染循环（`animate`函数）中每一帧都设置`needsUpdate = true`，这会造成巨大的性能浪费，使GPU渲染的优势荡然无存。

---

## 3. 纹理`format`与自动归一化

这是`DataTexture`最核心、也最容易混淆的概念之一。

### 什么是自动归一化 (Automatic Normalization)?

当GPU被告知它处理的是"颜色"信息时，它会默认提供一项服务：将一个整数范围（如`0-255`）或（`-32768 - 32767`）自动线性映射到标准的浮点数范围 `[0.0, 1.0]` 或 `[-1.0, 1.0]`。这个过程便于后续的光照、混合等计算。

### `format` 的选择决定了GPU的行为

| Format                                                     | 你的意图           | GPU行为              | 在着色器中得到的值                  | 适用场景                                                                                                  |
| :--------------------------------------------------------- | :----------------- | :------------------- | :---------------------------------- | :-------------------------------------------------------------------------------------------------------- |
| `THREE.RedFormat` <br/> `THREE.RGBAFormat`等               | "这是**颜色**数据" | **自动归一化**       | `0.0`到`1.0`或`-1.0`到`1.0`的浮点数 | 用于显示普通图像，进行标准光照和颜色计算。                                                                |
| `THREE.RedIntegerFormat` <br/> `THREE.RGBAIntegerFormat`等 | "这是**纯数据**"   | **保持原样，不处理** | 原始的、未经修改的整数              | 当纹理存储的不是颜色，而是有明确物理意义或计算意义的**原始数值**时（如DICOM的HU值、深度信息、ID映射等）。 |

### 为什么DICOM渲染必须用 `Integer` 格式？

我们的窗宽窗位算法依赖于原始的HU值（如-1000, 40, 1024）。如果GPU对这些值进行了归一化，将它们变成了`[-1.0, 1.0]`之间的小数，我们的整个计算逻辑就会完全失效。

因此，使用 `THREE.RedIntegerFormat`，并配合GLSL 3.00中的整数采样器 `isampler2D`，是我们能够**在着色器中获取到未被污染的原始整数值**，从而进行正确科学计算的根本保证。
